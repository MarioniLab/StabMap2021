---
title: "StabMap simulation: COVID PBMC CITE-seq"
author: "Shila Ghazanfar"
date: "28/05/2021"
output:
       html_document:
                     toc: true
                     toc_float:
                           collapsed: false
                           smooth_scroll: false
                     code_folding: hide
                     fig_width: 10 
                     fig_height: 8
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE,
                      cache = FALSE, cache.lazy = FALSE)
```

```{r}
set.seed(2021)
```

Load scripts and packages.

```{r}
library(reshape)
source("../scripts/initialise.R")
```

Subsetting data. The following was run on the EBI cluster to subset to 
10000 cells

```{r, eval = FALSE}
###### randomly subset
# run on the EBI cluster just once adn copied from
# /nfs/research1/marioni/shila/StabMap/CovidPBMC to
# ../../CovidPBMC

if (FALSE) { # since run on server
  adt = readRDS("Covid_ADT_SCE.RDS")
  sce = readRDS("Covid_SCE.RDS")
  
  subset_cells = sample(colnames(adt), 10000)
  
  adt_sub = adt[,subset_cells]
  sce_sub = sce[,subset_cells]
  
  saveRDS(adt_sub, file = "Covid_ADT_SCE_sub.Rds")
  saveRDS(sce_sub, file = "Covid_SCE_sub.Rds")
  # then copy to local
}

```


Data

```{r}

# load data as two separate SCE objects
adt_raw = readRDS("../../CovidPBMC/Covid_ADT_SCE_sub.Rds")
sce_raw = readRDS("../../CovidPBMC/Covid_SCE_sub.Rds")

# normalise the ADT logcounts
adt_raw = computeSumFactors(adt_raw)
adt_raw = logNormCounts(adt_raw)






sce = sce_raw
adt = adt_raw

colors <- viridis::viridis(length(unique(sce$full_clustering)))
names(colors) <- unique(sce$full_clustering)

# remove rows with zero variation
adt <- adt[rowVars(counts(adt)) > 0,]

# remove rows with zero variation for sce too
sce <- sce[rowVars(counts(sce)) > 0,]

# assay(adt, "logcounts") = log(edgeR::cpm(counts(adt)) + 1)

# normalise the SCE logcounts
sce = logNormCounts(sce)

# save the sce metadata as it's own file
# saveRDS(colData(sce), file = "../../CovidPBMC/Covid_SCT_meta_sub.RDS")

# reset rownames to symbols for sce
rownames(sce) <- make.unique(rowData(sce)[, "Symbol"])

# remove some of the proteins that were controls
prot_rmv = rowData(adt)[,"Symbol"] %in% c("IgG1_Ctrl", "IgG2a_Ctrl", "IgG2b_Ctrl", "IgG2b_RatCtrl")
adt <- adt[!(rownames(adt) %in% prot_rmv),]

if (TRUE) {
  # load protein ID mapping table (from Mike)
  mapping = read.csv("../../CovidPBMC/Covid_Protein-Gene_mapping.csv",
                     header = TRUE, row.names = 1)
  mapping$Gene_first = gsub("/.+", "", mapping$Gene)
  # set NA values as explicitly missing
  mapping$Gene_first[is.na(mapping$Gene_first)] <- paste0("MissingGene_", seq_len(sum(is.na(mapping$Gene_first))))
  
  # rename adt columns to first Gene
  rownames(adt) <- make.unique(mapping[rowData(adt)[,"ID"], "Gene_first"])
} else {
  rownames(adt) <- rowData(adt)[, "Symbol"]
}

# check that cell names are the same
identical(colnames(adt), colnames(sce))

# slightly rename the columns of adt, so we can tell them apart after stabmapping
colnames(adt) <- paste0(colnames(adt), "_adt")

# 42 proteins are directly comparable (by simply intersecting names)
# but after matching 175 proteins have associated genes
length(intersect(rownames(adt), rownames(sce)))

# cell type labels given
table(sce$full_clustering)

# extract a set of HVGs for the SCT data and subset
stats <- modelGeneVar(sce)
HVGs = getTopHVGs(stats)
sce <- sce[HVGs, ]



# convert logcounts assays into dense matrices (not required AFAIK)
#logcounts(adt) <- as.matrix(logcounts(adt))
#logcounts(sce) <- as.matrix(logcounts(sce))

# overlapping = intersect(rownames(adt), HVGs)

# input data
SCE_list = list(adt = adt[,],
                sce = sce[,])
assayNames = list(adt = "logcounts",
                  sce = "logcounts")

assay_list = mapply(assay, SCE_list, assayNames)
counts_list = mapply(assay, SCE_list, "counts")

# assay_list <- lapply(
#   assay_list,
#   function(x) t(scale(t(x), center = TRUE, scale = TRUE))
# )

grouping = "full_clustering"
k = 50

plotFeatureOverlaps(assay_list)

```

Perform StabMap and other methods

```{r}


# PCA embedding (naive)
PC_embedding = mapPCA(assay_list = assay_list,
                      nPCs = k)
dim(PC_embedding)
# PC_umap = calculateUMAP_rnames(reducedMNN_batchFactor(PC_embedding,
#                                                       batchFactor, k = 20))
# plot(PC_umap, col = 1+as.integer(batchFactor[rownames(PC_embedding)]))
# saveRDS(PC_embedding, file = "../../CovidPBMC/PC_embedding_sub.Rds")

if (TRUE) {
  # UINMF embedding
  UINMF_embedding = UINMF_wrap(counts_list = counts_list,
                               ncomponentsSubset = k)
  dim(UINMF_embedding)
  # saveRDS(UINMF_embedding, file = "../../CovidPBMC/UINMF_embedding_sub.Rds")
  
  # liger embedding (i.e. no unshared features)
  genes = Reduce(intersect, lapply(counts_list, rownames))
  counts_list_sub = lapply(counts_list, function(x) x[genes,])
  liger_embedding = UINMF_wrap(counts_list = counts_list_sub,
                               ncomponentsSubset = k)
  dim(liger_embedding)
  # saveRDS(liger_embedding, file = "../../CovidPBMC/liger_embedding_sub.Rds")
}

# LD embedding
# LD_embedding = stabMapLabelled(referenceSCE = sce,
#                                querySCE = adt,
#                                grouping = grouping,
#                                assayNameReference = assayNames[["sce"]],
#                                assayNameQuery = assayNames[["adt"]],
#                                prop_explained = 1)
# dim(LD_embedding)
# saveRDS(LD_embedding, file = "../../CovidPBMC/LD_embedding_sub.Rds")

# stable comparative
# SC_embedding = stabMapComparative(SCE_list = SCE_list,
#                                   assayNames = assayNames,
#                                   sparse = FALSE,
#                                   ncomponentsFull = 50,
#                                   ncomponentsSubset = k)
# dim(SC_embedding)
# saveRDS(SC_embedding, file = "../../CovidPBMC/SC_embedding_sub.Rds")

SC_embedding = stabMapGeneralised(assay_list = assay_list,
                                  reference_list = c("adt", "sce"),
                                  # assayNames = assayNames,
                                  # sparse = FALSE,
                                  projectAll = TRUE,
                                  ncomponentsReference = k,
                                  ncomponentsSubset = k,
                                  plot = FALSE,
                                  scale.center = TRUE,
                                  scale.scale = TRUE)
dim(SC_embedding)
# saveRDS(SC_embedding, file = "../../CovidPBMC/SC_embedding_sub.Rds")
# SC_umap = calculateUMAP_rnames(SC_embedding)
# SC_umap = calculateUMAP_rnames(reducedMNN_batchFactor(SC_embedding,
#                                                       batchFactor, k = 20))
# plot(SC_umap, col = 1+as.integer(batchFactor[rownames(SC_embedding)]))



SC_embedding_adt = stabMapGeneralised(assay_list = assay_list,
                                  reference_list = c("adt"),
                                  # assayNames = assayNames,
                                  # sparse = FALSE,
                                  projectAll = TRUE,
                                  ncomponentsReference = k,
                                  ncomponentsSubset = k,
                                  plot = FALSE,
                                  scale.center = TRUE,
                                  scale.scale = TRUE)
dim(SC_embedding_adt)
# saveRDS(SC_embedding, file = "../../CovidPBMC/SC_embedding_sub.Rds")
# SC_umap = calculateUMAP_rnames(SC_embedding)
# SC_umap_adt = calculateUMAP_rnames(reducedMNN_batchFactor(SC_embedding_adt,
#                                                       batchFactor, k = 20))
# plot(SC_umap_adt, col = 1+as.integer(batchFactor[rownames(SC_embedding_adt)]))


SC_embedding_sce = stabMapGeneralised(assay_list = assay_list,
                                  reference_list = c("sce"),
                                  # assayNames = assayNames,
                                  # sparse = FALSE,
                                  projectAll = TRUE,
                                  ncomponentsReference = k,
                                  ncomponentsSubset = k,
                                  plot = FALSE,
                                  scale.center = TRUE,
                                  scale.scale = TRUE)
dim(SC_embedding_sce)
# SC_umap_sce = calculateUMAP_rnames(reducedMNN_batchFactor(SC_embedding_sce,
#                                                       batchFactor, k = 20))
# plot(SC_umap_sce, col = 1+as.integer(batchFactor[rownames(SC_embedding_sce)]))


MultiMAP_embedding = MultiMAP_wrap(assay_list = assay_list)
dim(MultiMAP_embedding)

# 
# SC_ref_embedding = stabMapComparative(SCE_list = SCE_list,
#                                       assayNames = assayNames,
#                                       stabilise = c(FALSE, TRUE),
#                                       sparse = FALSE,
#                                       ncomponentsFull = 50,
#                                       ncomponentsSubset = k)
# dim(SC_ref_embedding)
# saveRDS(SC_ref_embedding, file = "../../CovidPBMC/SC_ref_embedding_sub.Rds")
# 
# # both LD and stabmap
# LD_SC_embedding = cbind(LD_embedding, SC_embedding)
# saveRDS(LD_SC_embedding, file = "../../CovidPBMC/LD_SC_embedding_sub.Rds")
# 
# ##
# Load all the embeddings as a list
# note that liger does some cell filtering, so they are not the 
# same size matrices. additionally they are not in the same row orders

embeddings = list(
  PC = PC_embedding,
  liger = liger_embedding,
  UINMF = UINMF_embedding,
  StabMap = SC_embedding,
  StabMap_sce = SC_embedding_sce,
  StabMap_adt = SC_embedding_adt,
  MultiMAP = MultiMAP_embedding
)

no_batch = c("liger", "UINMF", "MultiMAP")

```


Batch correct and plot

```{r}

batchFactor = factor(ifelse(grepl("adt", rownames(embeddings[[1]])),
                            "ADT", "SCT"))
names(batchFactor) <- rownames(embeddings[[1]])

type = batchFactor

ct_all = unlist(lapply(lapply(SCE_list, colData), "[", , grouping))
names(ct_all) <- unlist(lapply(lapply(SCE_list, colData), rownames))

celltype_colours = colors


embeddings_corrected = sapply(names(embeddings), function(nm) { 
  print(nm)
  embedding = embeddings[[nm]]
  if (nm %in% no_batch) return(embedding)
  return(reducedMNN_batchFactor(
    # Harmony_batchFactor(
    as.matrix(embedding), batchFactor = batchFactor[rownames(embedding)]))
}
)
# saveRDS(embeddings_corrected, file = "../../CovidPBMC/embeddings_corrected_sub.Rds")


UMAPs_corrected = lapply(embeddings_corrected, calculateUMAP_rnames)
# saveRDS(UMAPs_corrected, file = "../../CovidPBMC/UMAPs_corrected_sub.Rds")


# plot
pl = function(embedding_UMAP, name, coltype = "type") {
  ind = sample(rownames(embedding_UMAP))
  df = data.frame(cell = ind,
                  U1 = embedding_UMAP[ind,1],
                  U2 = embedding_UMAP[ind,2],
                  type = factor(type[ind]),
                  ctype = ct_all[ind])
  df$col = df[,coltype]
  p = ggplot(df, aes(x = U1, y = U2, colour = col)) + 
    geom_point(size = 0.5, alpha = 0.5) +
    theme_classic() + 
    theme(legend.position = "none") +
    coord_fixed() +
    ggtitle(name)
  
  if (coltype == "ctype") {
    p <- p + scale_colour_manual(values = celltype_colours)
  }
  
  return(p)
}
# 
# embeddings_corrected_UMAP = sapply(embeddings_names, function(nm){
#   if (nm == "MultiMAP_embedding") return(get(nm)) # i.e. do nothing
#   calculateUMAP_rnames(get(paste0(nm, "_corrected")))
# }, simplify = FALSE)

p_corrected = 
  wrap_plots(
    c(
      mapply(pl, UMAPs_corrected, names(UMAPs_corrected), SIMPLIFY = FALSE),
      mapply(pl, UMAPs_corrected, names(UMAPs_corrected), MoreArgs = list(coltype = "ctype"), SIMPLIFY = FALSE)
    )) +
  plot_layout(nrow = 2, ncol = length(UMAPs_corrected), byrow = TRUE)
p_corrected

```

Predict cell type labels

```{r}

# predict cell type labels using knn with k = 5
# treat RNA as the reference
referenceLabels = colData(sce)[,grouping]
names(referenceLabels) = colnames(sce)

queryLabels = colData(adt)[,grouping]
names(queryLabels) = colnames(adt)

# calculate accuracy of the query cells
embeddings_accuracy = sapply(names(embeddings_corrected), function(nm) {
  print(nm)
  
  # only use cells with labels
  # data_all = get(paste0(nm, "_corrected"))
  data_all = embeddings_corrected[[nm]]
  labels_train = referenceLabels[!is.na(referenceLabels)]
  
  knn_out = embeddingKNN(data_all,
                         labels_train,
                         type = "uniform_fixed",
                         k_values = 5)
  
  acc = mean(isEqual(knn_out[names(queryLabels),"predicted_labels"], queryLabels), na.rm = TRUE)
  
  acc_bal = mean(unlist(lapply(split(isEqual(knn_out[names(queryLabels),"predicted_labels"], queryLabels), queryLabels), mean, na.rm = TRUE)))
  
  return(list(acc = acc, acc_bal = acc_bal))
}, simplify = FALSE)


res = data.frame(
  type = names(embeddings_corrected),
  Accuracy = unlist(lapply(embeddings_accuracy, "[[", "acc")),
  Accuracy_balanced = unlist(lapply(embeddings_accuracy, "[[", "acc_bal"))
)
res <- res[order(res$Accuracy_balanced, decreasing = TRUE),]
res$type <- factor(res$type, levels = res$type)

typesToKeep = c("MultiMAP",
                "PCA",
                "StabMap",
                "StabMap_adt",
                "StabMap_sce",
                "UINMF",
                "liger")

g1 = ggplot(subset(res, type %in% typesToKeep), aes(x = type, y = Accuracy_balanced)) + 
  theme_classic() +
  stat_summary(aes(width = 0.8, fill = type), geom = "bar", fun = "mean", position = "dodge") +
  # stat_summary(aes(group = type, colour = type), geom = "errorbar", fun.data = "mean_se", position = "dodge", width = 0.8) +
  labs(fill = "") +
  theme_classic() +
  NULL
# g1
# print(g1)
g2 = ggplot(subset(res, type %in% typesToKeep), aes(x = type, y = Accuracy)) + 
  theme_classic() +
  stat_summary(aes(width = 0.8, fill = type), geom = "bar", fun = "mean", position = "dodge") +
  # stat_summary(aes(group = type, colour = type), geom = "errorbar", fun.data = "mean_se", position = "dodge", width = 0.8) +
  labs(fill = "") +
  xlab("") +
  theme_classic() +
  NULL
g2

g1 + g2

```

Jaccard neighbourhood, large jaccard is better

```{r}
k1 = 50
# k1 = 200
k2 = k1

embeddings_jaccard = sapply(names(embeddings_corrected), function(nm) {
  
  print(nm)
  
  # embedding = get(paste0(nm, "_corrected"))
  embedding = embeddings_corrected[[nm]]
  # split into two matching matrices
  is_RNA = !grepl("adt", rownames(embedding))
  embedding_RNA = embedding[is_RNA,]
  embedding_ATAC = embedding[!is_RNA,]
  rownames(embedding_ATAC) <- gsub("_adt", "", rownames(embedding_ATAC))
  cells = intersect(rownames(embedding_RNA), rownames(embedding_ATAC))
  embedding_RNA_common = embedding_RNA[cells,]
  embedding_ATAC_common = embedding_ATAC[cells,]
  
  embedding_jaccard = embeddingJaccard(embedding_RNA_common, embedding_ATAC_common,
                                       k1 = k1, k2 = k2)
  return(embedding_jaccard)
}, simplify = FALSE)
# names(embeddings_jaccard) <-  gsub(".+/|_embedding.Rds","",names(embeddings_jaccard))

# also want to compare against PC separate, using all data available
pc_atac = calculatePCA(adt)
pc_rna = calculatePCA(sce)
rownames(pc_atac) <- gsub("_adt", "", rownames(pc_atac))
cells = intersect(rownames(pc_atac), rownames(pc_rna))
pc_rna_common = pc_rna[cells,]
pc_atac_common = pc_atac[cells,]

embeddings_jaccard[["PC_separate"]] <- embeddingJaccard(
  pc_rna_common, pc_atac_common,
  k1 = k1, k2 = k2)

emb = sort(unlist(lapply(embeddings_jaccard, median)))
emb
boxplot(embeddings_jaccard[names(emb)], ylab = "Jaccard similarity", main = k1)
# }

df_jaccard = data.frame(type = rep(names(embeddings_jaccard), times = unlist(lapply(embeddings_jaccard, length))),
                        jaccard = unlist(embeddings_jaccard)
)
df_jaccard$type <- factor(df_jaccard$type, levels = names(emb))

g = ggplot(subset(df_jaccard, type %in% c(typesToKeep, "PC_separate")), aes(x = type, y = jaccard, fill = type)) + 
  theme_classic() +
  geom_boxplot() +
  labs(fill = "") +
  ylab("Jaccard similarity between RNA and ATAC modalities") +
  xlab("") +
  NULL
print(g)

```

Closest neighbour, how many other cells until you reach the corresponding cell

```{r}

# nei_pos_list = list()
k_max = 1000

nei_pos_list = sapply(names(embeddings_corrected), function(nm) {
  
  print(nm)
  
  # embedding = get(paste0(nm, "_corrected"))
  
  embedding = embeddings_corrected[[nm]]
  
  nei_atac = queryNamedKNN(embedding[!grepl("_adt", rownames(embedding)),],
                           embedding[grepl("_adt", rownames(embedding)),],
                           k = k_max)
  nei_atac_bin = apply(nei_atac, 2, function(x) isEqual(gsub("_adt", "", rownames(nei_atac)), x))
  nei_atac_pos = max.col(nei_atac_bin, ties.method = "last")
  mean(nei_atac_pos)
  nei_rna = queryNamedKNN(embedding[grepl("_adt", rownames(embedding)),],
                          embedding[!grepl("_adt", rownames(embedding)),],
                          k = k_max)
  nei_rna_bin = apply(nei_rna, 2, function(x) isEqual(paste0(rownames(nei_rna), "_adt"), x))
  nei_rna_pos = max.col(nei_rna_bin, ties.method = "last")
  mean(nei_rna_pos)
  
  nei_pos = c(nei_atac_pos, nei_rna_pos)
  names(nei_pos) <- c(rownames(nei_atac), rownames(nei_rna))
  
  # nei_pos_list[[i]] <- nei_pos
  return(nei_pos)
  
}, simplify = FALSE)

# names(nei_pos_list) <- names(embeddings_corrected)
# here a smaller number of nei is better
sort(unlist(lapply(nei_pos_list, function(x) sum(x < 10))))
sort(unlist(lapply(nei_pos_list, mean)))
boxplot(nei_pos_list, las = 2)


xvals = c(5,10,20,30,50,100,200,500,1000)
nei_x = sapply(xvals,
               function(y) unlist(lapply(nei_pos_list, function(x) sum(x < y))))
colnames(nei_x) <- xvals

nei_df = reshape::melt(nei_x)
nei_df$X1 <- factor(rownames(nei_x), levels = names(sort(nei_x[,1], decreasing = TRUE)))

ggplot(nei_df, aes(x = X2, y = value, group = X1)) + 
  theme_classic() +
  geom_line(aes(colour = X1, linetype = X1), size = 1) + 
  scale_y_log10() +
  scale_x_log10() +
  labs(colour = "", linetype = "") +
  xlab("X") +
  ylab("Number of cells with at most X cells closer to matching cell") +
  NULL


```

Split UMAP plot

```{r, eval = FALSE}

splitMultiomeUMAP = function(UMAP){
  is_RNA = !grepl("adt", rownames(UMAP))
  UMAP_RNA = UMAP[is_RNA,]
  UMAP_ATAC = UMAP[!is_RNA,]
  rownames(UMAP_ATAC) <- gsub("_adt", "", rownames(UMAP_ATAC))

  cells = intersect(rownames(UMAP_RNA), rownames(UMAP_ATAC))
  UMAP_split = cbind(UMAP_RNA[cells,], UMAP_ATAC[cells,])
  colnames(UMAP_split) <- c("UMAP1_RNA", "UMAP2_RNA", "UMAP1_ATAC", "UMAP2_ATAC")
  return(UMAP_split)
}


```


Experimental:

```{r, eval = FALSE}

# experimental, generate a side-by-side to find the corresponding
# cells in the UMAP
library(ggiraph)

i = "StabMap"

df = as.data.frame(splitMultiomeUMAP(embeddings_corrected_UMAP[[i]]))
df$cell = rownames(df)
df$celltype = colData(sce.rna[,rownames(df)])[,grouping]

g0 = pl(embeddings_corrected_UMAP[[i]], i)

gg0 <- ggplot(df) +
  theme_classic() +
  geom_point_interactive(aes(x = UMAP1_RNA, y = UMAP2_RNA, 
                             tooltip = cell, data_id = cell), 
                         color = "red", size = .5) +
  geom_point_interactive(aes(x = UMAP1_ATAC, y = UMAP2_ATAC, 
                             tooltip = cell, data_id = cell), 
                         color = "blue", size = .5) +
  theme(legend.position = "none") + 
  ggtitle(paste0(i, " - all"))

gg1 <- ggplot(df) +
  theme_classic() +
  geom_point_interactive(aes(x = UMAP1_ATAC, y = UMAP2_ATAC), colour = "grey", size = .5) +
  geom_point_interactive(aes(x = UMAP1_RNA, y = UMAP2_RNA, color = celltype, 
                             tooltip = cell, data_id = cell), size = .5) +
  theme(legend.position = "none") + 
  ggtitle(paste0(i, " - RNA"))

gg2 <- ggplot(df) +
  theme_classic() +
  geom_point_interactive(aes(x = UMAP1_RNA, y = UMAP2_RNA), colour = "grey", size = .5) +
  geom_point_interactive(aes(x = UMAP1_ATAC, y = UMAP2_ATAC, color = celltype, 
                             tooltip = cell, data_id = cell), size = .5) +
  theme(legend.position = "none") +
  ggtitle(paste0(i, " - ATAC"))

g0 + gg1 + gg2

girafe(ggobj = plot_grid(gg0, gg1, gg2), width_svg = 8, height_svg = 4,
       options = list(
         opts_selection(type = "multiple",
                        css = "fill:#FF3333;stroke:black;",
                        only_shiny = FALSE)
       ))


```


Finish

```{r}
sessionInfo()
```

