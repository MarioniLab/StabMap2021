---
title: "StabMap: Mouse Gastrulation and Spatial Mouse Atlas"
author: "Shila Ghazanfar"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
       html_document:
                     toc: true
                     toc_float:
                           collapsed: false
                           smooth_scroll: false
                     code_folding: hide
                     fig_width: 10 
                     fig_height: 8
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE,
                      cache = FALSE, cache.lazy = FALSE)
```

```{r}
set.seed(2021)
```

Load scripts and packages.

```{r}
library(MouseGastrulationData)
source("../scripts/initialise.R")
library(igraph)
```

Load scripts from MarioniLab/SpatialMouseAtlas2020 Github repository

```{r, include=FALSE}
library(httr)
req <- GET("https://api.github.com/repos/MarioniLab/SpatialMouseAtlas2020/git/trees/main?recursive=1")
stop_for_status(req)
filelist <- unlist(lapply(content(req)$tree, "[", "path"), use.names = F)
suffixes = grep("functions/", filelist, value = TRUE, fixed = TRUE)

urls = paste0("https://raw.githubusercontent.com/MarioniLab/SpatialMouseAtlas2020/main/", suffixes)

source_https <- function(url, ...) {
  # load package
  require(RCurl)
  # parse and evaluate each .R script
  sapply(c(url, ...), function(u) {
    eval(parse(text = getURL(u, followlocation = TRUE, cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl"))), envir = .GlobalEnv)
  })
}

sapply(urls, source_https)
source_https(paste0("https://raw.githubusercontent.com/MarioniLab/SpatialMouseAtlas2020/main/scripts/celltype_colours.R"))
```

Load data via the MouseGastrulationData Bioconductor package.

```{r}
stages = c("E8.5")

mt = MouseGastrulationData::AtlasSampleMetadata
samples = mt[mt[, "stage"] %in% stages, "sample"]

atlas_raw = EmbryoAtlasData(type = "processed", samples = samples)
atlas_raw <- logNormCounts(atlas_raw)

atlas = atlas_raw

celltype_colours_atlas = MouseGastrulationData::EmbryoCelltypeColours

ct_all = atlas$celltype
names(ct_all) <- colnames(atlas)

# the sample information is used in the simulation below
table(atlas$sample)

# Feature selection
decomp <- modelGeneVar(atlas)
plot(decomp$mean, decomp$total)
hvgs <- rownames(decomp)[decomp$mean>0.01 & decomp$p.value <= 0.05]
points(decomp[hvgs,]$mean, decomp[hvgs,]$total, col = "blue")
length(hvgs)
atlas <- atlas[hvgs,]

rownames(atlas) <- make.unique(rowData(atlas)$SYMBOL)

labels = "celltype"
```

# Load seqFISH data

Downloaded from the data content server. 

```{r}
meta = readRDS("../../LohoffSeqFISH/metadata.Rds")
exprs = readRDS("../../LohoffSeqFISH/exprs.Rds")
graph = readRDS("../../LohoffSeqFISH/neighbourGraph_1.3.Rds")

sce = SingleCellExperiment(assays = list(logcounts = exprs),
                           colData = meta)

batch = meta[, "pos"]
table(batch)
```

# Calculate neighbourhood expression of seqFISH cells

```{r}
sceSplit = splitSCE(sce, interaction(sce$embryo, sce$z))

graph_dist_list = lapply(sceSplit, function(sce_sub) {
  
  # subset to relevant cells
  graph_sub = induced.subgraph(graph, V(graph)$name %in% colnames(sce_sub))
  
  # add the remaining cells as unconnected nodes in the graph
  graph_sub = igraph::add.vertices(graph_sub, length(setdiff(colnames(sce_sub), V(graph_sub)$name)), 
                                   attr = list(name = setdiff(colnames(sce_sub), V(graph_sub)$name)))
  
  graph_dist = igraph::distances(graph_sub, mode = "all")
  
  # setting diag() to Inf means that the cell itself is not included in the 
  # weighted mean calculation
  # if instead I set it to 1, then itself is included in the calculation
  diag(graph_dist) <- Inf
  graph_dist[1:5,1:5]
  return(graph_dist)
})

# get smoothed expression
smoothlist = sapply(names(sceSplit), function(s) {
  sce_sub = sceSplit[[s]]
  graph_dist = graph_dist_list[[s]][colnames(sce_sub), colnames(sce_sub)]
  
  print(s)
  
  # only mean of immediate neighbours, not including self either
  graph_dist[graph_dist != 1] <- Inf
  
  allsmooth = weightedMeanMatrix(logcounts(sce_sub), graph_dist)
  
}, simplify = FALSE)

smooth = do.call(cbind, smoothlist)[, colnames(sce)]
smooth[is.na(smooth)] <- NA

rownames(smooth) <- paste0(rownames(smooth), "_neighbours")

smooth <- as.matrix(smooth)

# point impute the cells without any neighbours, with their
# own expression values
smooth[is.na(smooth)] <- as.matrix(logcounts(sce))[is.na(smooth)]
```

Combine data into one

```{r}
seqFISH = rbind(logcounts(sce), smooth)

dim(seqFISH)
```

Integrate seqFISH and atlas only using StabMap

```{r}
assay_list = list(
  seqFISH = as.matrix(seqFISH),
  atlas = as.matrix(logcounts(atlas))
)

mosaicDataUpSet(assay_list)

meta <- meta[colnames(seqFISH),]

SC_coord = setNames(c(meta[,"embryo"], rep("atlas", ncol(atlas))),
                    c(rownames(meta), colnames(atlas)))
table(SC_coord)

SC_batch = setNames(c(interaction(meta[,"z"], meta[,"embryo"]), atlas$sample),
                    c(rownames(meta), colnames(atlas)))
table(SC_batch)

SC_type = setNames(c(rep("seqFISH", nrow(meta)), rep("atlas", ncol(atlas))),
                   c(rownames(meta), colnames(atlas)))
table(SC_type)

cols = setNames(c(celltype_colours[as.character(meta[,"celltype_mapped_refined"])],
                  celltype_colours[as.character(atlas$celltype)]),
                c(rownames(meta), colnames(atlas))
)

celltypes = setNames(c(as.character(meta[,"celltype_mapped_refined"]),
                       as.character(atlas$celltype)),
                     c(rownames(meta), colnames(atlas))
)

PC = mapPCA(assay_list)
colnames(PC) <- paste0("joint_PC", seq_len(ncol(PC)))
PC_corrected = reducedMNN_batchFactor(PC, SC_batch)
PC_corrected_umap = calculateUMAP_rnames(PC_corrected)

SC_out = stabMap(assay_list,
                 reference_list = c("atlas", "seqFISH"),
                 projectAll = TRUE,
                 plot = FALSE,
                 scale.center = TRUE,
                 scale.scale = TRUE)

SC = reWeightEmbedding(SC_out, 
                       weights = list("seqFISH_PC" = 1,
                                      "atlas_PC" = 1
                                      ))

SC_corrected = reducedMNN_batchFactor(SC, SC_batch)

SC_corrected_umap = calculateUMAP_rnames(SC_corrected)
```

```{r}
coord_x = setNames(c(meta[,"x_global_affine"],
                     reducedDim(atlas, "umap")[,1]),
                   c(rownames(meta), colnames(atlas))
                   )

coord_y = setNames(c(-meta[,"y_global_affine"],
                     reducedDim(atlas, "umap")[,2]),
                   c(rownames(meta), colnames(atlas))
                   )
```

Output files

```{r}
SC_corrected_list = list(
  StabMap_uncorrected = SC,
  StabMap_corrected = SC_corrected,
  StabMap_umap = SC_corrected_umap,
  StabMap_meta = data.frame(cell = rownames(SC_corrected),
                            batch = SC_batch[rownames(SC_corrected_umap)],
                            type = SC_type[rownames(SC_corrected_umap)],
                            celltype = celltypes[rownames(SC_corrected_umap)],
                            colour = cols[rownames(SC_corrected_umap)],
                            coord_x = coord_x[rownames(SC_corrected_umap)],
                            coord_y = coord_y[rownames(SC_corrected_umap)]),
  PC_uncorrected = PC,
  PC_corrected = PC_corrected,
  PC_umap = PC_corrected_umap
)
saveRDS(SC_corrected_list, file = "../../output/MGA_seqFISH_StabMap_list.Rds")

saveRDS(assay_list, file = "../../output/MGA_seqFISH_StabMap_assay_list.Rds")
```

# Finish

```{r}
sessionInfo()
```
